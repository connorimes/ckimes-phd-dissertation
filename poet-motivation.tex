\section{Motivation}
\label{sec:poet-motivation}

To motivate the need for POET, we summarize prior work \cite{Imes2014}.
We evaluate the timing and energy tradeoffs of a video encoder on two embedded platforms, a Sony Vaio tablet and an ODROID development board.
The two platforms not only have different resources for management, but also have latency and energy tradeoffs with different topologies.
Thus, resource allocation strategies that save energy on one are wasteful on the other.

\begin{table}[t]
\caption{Two embedded platforms with different configurable components.}
\label{tbl:poet-machines}
\tiny
\centering
\begin{tabular}{lcccccccc}
  \textbf{Platform} & 
  \textbf{Processor} &
  \textbf{Cores} & 
  \textbf{Core Types} &
  \textbf{Speeds (GHz)} &
  \textbf{TurboBoost} &
  \textbf{HyperThreads} & 
  \textbf{Num. Configs} \\
  % \textbf{Configurations} \\
  \hline
  \hline
  SVT11226CXB & Intel Haswell  & 2 & 1             & 0.6--1.5          & yes & yes & 46 \\
  ODROID-XU+E & ARM big.LITTLE & 8 & 2 (A15, A7)   & 0.8--1.6, 0.5--1.2 & no  & no  & 70 \\
  \hline 
  \hline
\end{tabular}
% \vskip -.7em
\end{table}

Our example features a video encoder, composed of jobs, where each job encodes a frame.
We instrument the encoder to report job latency and we measure the platform's energy consumption over time.
The two platforms have different configurable resources, shown in \tblref{poet-machines}.
The Vaio allows configuration of the number of active cores, the number of hyperthreads per core, the speed of the processors, and the use of TurboBoost.
The ODROID, supports configuration of the number of active cores, their clock speed, and whether the application uses the ``big'' (Cortex-A15 high performance, high power) or ``LITTLE'' (Cortex-A7 low performance, low power) cores.

\figref{poet-x264-motivation-tradeoffs} shows the tradeoffs between energy consumption and latency.
The x-axis shows the average latency (normalized to 1---the empirically determined worst case).
The y-axis shows energy (normalized to 1---the highest measured energy).
The two plots show the very different tradeoffs for the Vaio and the ODROID with each point representing a different configuration.
For the Vaio, energy increases as frame latency increases; \ie a slower job wastes energy.
For the ODROID, energy decreases as frame latency increases; \ie slower encodings save energy.

\begin{figure}[t]
  % \vskip -1.8em
  \centering
  \subfloat[Energy/Latency Tradeoffs]%
  {\input{img/poet/tradeoffs.tex}%
  \label{fig:poet-x264-motivation-tradeoffs}}
  \subfloat[Energy Consumption]%
  {\input{img/poet/heuristics.tex}%
  \label{fig:poet-x264-motivation-heuristics}}
  \caption{Energy/latency tradeoffs.}
  \label{fig:poet-x264-motivation}
\end{figure}

The different shapes of these tradeoff spaces lead to different optimal resource allocation strategies.
Empirical studies show that the \emph{race-to-idle} heuristic, which makes all resources available and then idles after completing a job, is near optimal on systems like the Vaio~\cite{PowerSlope,Hoelzle2009,google,Imes2014,HotPower}.
On systems like the ODROID, recent approaches save energy by keeping the system constantly busy and \emph{never-idle}~\cite{Carroll13,LeSueur11,Lin2010,Imes2014,HotPower}.

To demonstrate the importance of choosing the right strategy, we analyze the two heuristics on both platforms and compare their energy consumption to optimal.
We set a latency target equal to twice the minimum latency and measure the energy consumption of encoding 500 video frames using each heuristic.
\figref{poet-x264-motivation-heuristics} shows the results, normalized to the optimal energy found by measuring every possible resource configuration.
Both heuristics meet the latency target, but their energy consumptions vary tremendously.
On the Vaio, \emph{race-to-idle} is near optimal, but \emph{never-idle} consumes 13\% more energy.
Conversely, \emph{never-idle} is near optimal for the ODROID, but \emph{race-to-idle} consumes $2 \times$ more energy.

These results demonstrate that resource allocation strategy greatly affects energy consumption, and more importantly, that heuristic solutions are \textbf{not portable} across devices.
These two points motivate the need for an approach like POET, which provides near optimal resource allocation while remaining platform-independent.
POET's runtime uses control theory to meet timing constraints and linear programming to minimize energy consumption.
A POET user does not need to be a control or optimization expert, but simply make small changes to their application code.
POET makes it easy for embedded developers to write portable applications providing predictable timing and minimal energy across a range of devices.
